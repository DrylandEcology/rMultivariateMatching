% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluateMatching.R
\name{evaluateGeoDist}
\alias{evaluateGeoDist}
\title{Evaluate matching with geographic distances}
\usage{
evaluateGeoDist(
  matches,
  subsetcells,
  subsetcells_id = "site_id",
  subset_in_target = TRUE,
  exclude_poor_matches = TRUE,
  matching_distance = 1.5,
  longlat = T,
  raster_template = NULL,
  map_distances = TRUE,
  map_neighbor_distances = TRUE,
  which_distance = "both",
  saverasters = FALSE,
  filepath = getwd()
)
}
\arguments{
\item{matches}{data frame output from the \code{\link{matchingquality}}
function.}

\item{subsetcells}{if \code{subset_in_target} is TRUE, this should be a data frame
of coordinates (expects coordinates in columns named 'x' and 'y') for Subset
cells. May be extracted from output from \code{\link{kpoints}} function or
provided separately. Row names should be unique identifiers for each point
(unique means no repeats in rownames of subsetcells if \code{subset_in_target} is
TRUE). If \code{subset_in_target} is FALSE, this should be a data frame of subset
cells with column names corresponding exactly to those in \code{matchingvars} and
row names should be unique identifiers (unique means no repeats among all
row names in targetcells and matchingvars if \code{subset_in_target} is FALSE).
See \code{subset_in_target}.}

\item{subsetcells_id}{character or numeric. Refers to the column in
\code{subsetcells}that provides the unique identifiers for target cells. Defaults
to NULL.}

\item{subset_in_target}{boolean. Indicates if Subset cells have been selected
from Target cells using \code{\link{kpoints}} function}

\item{matching_distance}{numeric. Gives the maximum allowable matching quality
value (weighted Euclidean distance) between Target and Subset cells. Default
value is 1.5.}

\item{longlat}{boolean. Pass to function in \code{\link[raster-pointDistance]{raster::pointDistance()}}.
Indicates if the coordinates are in longitude and latitude format for calculating
distances between points. Default value is TRUE and coordinates need to be
provided in this format.}

\item{raster_template}{one of the raster layers used for input data.}

\item{map_distances}{boolean. Indicates whether a map of distances between
Target and matched Subset cells should be plotted. Defaults to TRUE.}

\item{map_neighbor_distances}{boolean. Indicates whether a map of average
distance between the Subset cells matched to each Target cell and the Subset
cells matched to the eight adjacent neighbors of that Target cell. Defaults to
TRUE.}

\item{which_distance}{character. One of 'both', 'simple', or 'neighbor'.
Determines which distance(s) will be calculated. 'simple' will calculate the
dstance between target and matched subset cells, 'neighbor' will calculate the
distance between the Subset cells matched to each Target cell and the Subset
cells matched to the eight adjacent neighbors of that Target cell. 'both' will
calculate both simple and neighbor distances.}

\item{saverasters}{boolean. Indicates whether to save rasters of the calculated
distance metrics. Defaults to FALSE.}

\item{filepath}{provides path for location where raster will be saved. Defaults
to working directory.}

\item{matchingvars_id}{character or numeric. Refers to the column in
\code{matchingvars}that provides the unique identifiers for target cells. Defaults
to "cellnumbers", which is the unique ID column created by \code{\link{makeInputdata}}.}
}
\value{
Data frame of the standard deviation of differences between Target and
their matched Subset cells for all variables supplied in \code{allvars} data frame.
The first row corresponds to the standard deviation of differences between
Target and Subset cells for all cells and the second row corresponds to the
standard deviation of differences between Target and Subset cells for only those
Target cells with matching quality <= \code{matching_distance}. Units are the same
as the units for each variable in \code{allvars}.
}
\description{
Calculate 1) distance between target and matched subset cells and 2) distance
between the Subset cells matched to each Target cell and the Subset cells
matched to the eight adjacent neighbors of that Target cell.
}
\examples{
# Load targetcells data for Target Cells (from rMultivariateMatchingAlgorithms package)
data(targetcells)
# Create data frame of potential matching variables for Target Cells
allvars <- makeInputdata(targetcells)
#' # Create vector of matching criteria
criteria <- c(0.7,42,3.3,66,5.4,18.4)
results1 <- kpoints(matchingvars,criteria = criteria,klist = 200,n_starts = 1,min_area = 50,iter = 50,raster_template = targetcells[[1]])
# For an example where subset_in_target is TRUE
# Get points from solution to kpoints algorithm
subsetcells <- results1$solutions[[1]]
# Find matches and calculate matching quality
quals <- matchingquality(matchingvars, subsetcells, matchingvars_id = "cellnumbers", raster_template = targetcells[[1]], subset_in_target = TRUE)
# Look at geographic distances
geodist <- evaluateGeoDist(matches = quals, subsetcells = subsetcells,
                           subsetcells_id = 'site_id', subset_in_target = TRUE,
                           exclude_poor_matches = TRUE, matching_distance = 1.5,
                           longlat = TRUE, raster_template = targetcells[[1]])


# For example with subset_in_target = FALSE
# Get points from solution to kpoints algorithm
data(subsetcells)
# Remove duplicates (representing cells with same climate but different soils--
# we want to match on climate only)
subsetcells <- subsetcells[!duplicated(subsetcells$site_id),]
# Pull out matching variables only, with site_id that identifies unique climate
subsetcells <- subsetcells[,c("site_id","X_WGS84","Y_WGS84",names(matchingvars)[4:9])]
# Ensure that site_id will be values unique to subsetcells
subsetcells$site_id <- paste0("00",subsetcells$site_id)
# Find matches and calculate matching quality
quals <- matchingquality(matchingvars, subsetcells=subsetcells, matchingvars_id = "cellnumbers",subsetcells_id = "site_id",
                         raster_template = targetcells[[1]], subset_in_target = FALSE)

# Look at geographic distances
geodist <- evaluateGeoDist(matches = quals, subsetcells = subsetcells,
                           subsetcells_id = 'site_id', subset_in_target = FALSE,
                           exclude_poor_matches = TRUE, matching_distance = 1.5,
                           longlat = TRUE, raster_template = targetcells[[1]])
}
