% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolatePoints.R
\name{interpolatePoints}
\alias{interpolatePoints}
\title{Interpolate output results}
\usage{
interpolatePoints(
  matches = NULL,
  output_results = NULL,
  exclude_poor_matches = TRUE,
  subset_cell_names = "subset_cell",
  quality_name = "matching_quality",
  matching_distance = 1.5,
  raster_template = NULL,
  plotraster = TRUE,
  filepath = getwd(),
  overwrite = FALSE
)
}
\arguments{
\item{matches}{data frame. Output from \code{multivarmatch} or \code{secondaryMatching}
functions.}

\item{output_results}{data frame. Simulation output results for all simulated
sites (Subset cells). The first column and the rownames should correspond to
the unique identifiers for the Subsetcells. Importantly, these identifiers
need to match the identifiers in the 'subset_cell' column of the 'matches'
data frame.}

\item{exclude_poor_matches}{boolean. Indicates whether poor matches (defined
as Target cells that are more than the designated 'matching_distance' from
their matched Subset cell) should be excluded from matching. Defaults to TRUE.}

\item{subset_cell_names}{character. This is the name of the column in the
'matches' data frame that provides the unique identity of the Subset cells
matched to each Target cell. Defaults to "subset_cell". When 'matches' is the
output from \code{secondaryMatching}, this should be 'subset_cell_secondary'.}

\item{quality_name}{character. This is the name of the column in the
'matches' data frame that provides the matching quality between the Subset cells
and Target cells. Defaults to ""matching_quality"". When 'matches' is the
output from \code{secondaryMatching}, this should be 'matching_quality_secondary'.}

\item{matching_distance}{numeric. Gives the maximum allowable matching quality
value (weighted Euclidean distance) between Target and Subset cells. Default
value is 1.5.}

\item{raster_template}{one of the raster layers used for input data.}

\item{plotraster}{boolean. Indicates if raster should be plotted to a map.
Defaults to TRUE.}

\item{filepath}{provides path for location where raster will be saved. Defaults
to working directory.}

\item{overwrite}{boolean. Indicates whether saving the rasters will be allowed
to overwrite existing files with the same name. Defaults to FALSE.}
}
\value{
Raster files of interpolated output variables.
}
\description{
Use multivariate matching to interpolate simulation output results to high
resolution maps
}
\examples{
# Load targetcells data for Target Cells
data(targetcells)

# Create data frame of potential matching variables for Target Cells
allvars <- makeInputdata(targetcells)
\
# Subset to include only matching variables
matchingvars <- allvars[,c("cellnumbers","x","y","bioclim_01","bioclim_04",
                       "bioclim_09","bioclim_12","bioclim_15","bioclim_18")]

# Create vector of matching criteria
criteria <- c(0.7,42,3.3,66,5.4,18.4)


# For an example where subset cells were generated from kpoints function
# Find solution for k = 200
results1 <- kpoints(matchingvars,criteria = criteria,klist = 200,n_starts = 1,
                    min_area = 50,iter = 50,raster_template = targetcells[[1]])

# Get points from solution to kpoints algorithm
subsetcells <- results1$solutions[[1]]

# Find matches and calculate matching quality
quals <- multivarmatch(matchingvars, subsetcells, criteria = criteria,
                         matchingvars_id = "cellnumbers",
                         raster_template = targetcells[[1]],
                         subset_in_target = TRUE)

# Create toy data set of "output variables"
# There are really just climate variables from the 'targetcells' rasters,
# but we will treat them as output variables to illustrate the method
output_results <- allvars[rownames(subsetcells),
                         c("cellnumbers","bioclim_02","bioclim_03",
                         "bioclim_16","bioclim_17")]

# Interpolate simulation output to rasters
interpolatePoints(matches = quals, output_results = output_results,
                  exclude_poor_matches = TRUE,
                  subset_cell_names = "subset_cell",
                  quality_name = "matching_quality",
                  matching_distance = 1.5, raster_template = targetcells[[1]],
                  plotraster = TRUE, filepath = getwd(),
                  overwrite = FALSE)


###################################
# Pull results from subsetcells
output_results <- subsetcells[,c("site_ids","Dryprop","CwetWinter","CdrySummer",
                                 "Cwet8","Dryall","Dryany")]
rownames(output_results) <- paste0("00",output_results$site_ids)

# Remove duplicates (representing cells with same climate but different soils--
# we want to match on climate only)
subsetcells <- subsetcells[!duplicated(subsetcells$site_id),]

# Pull out matching variables only, with site_id that identifies unique climate
subsetcells1 <- subsetcells[,c("site_id","X_WGS84","Y_WGS84","bioclim_01",
                           "bioclim_04","bioclim_09","bioclim_12",
                           "bioclim_15","bioclim_18")]

# Ensure that site_id will be values unique to subsetcells
subsetcells1$site_id <- paste0("00",subsetcells$site_id)

# Find matches and calculate matching quality
quals <- multivarmatch(matchingvars, subsetcells=subsetcells1,
                         criteria = criteria,
                         matchingvars_id = "cellnumbers",
                         subsetcells_id = "site_id",
                         raster_templat = targetcells[[1]],
                         subset_in_target = FALSE)

# Bring in matching variables for secondary matching
# Subset to include only secondaryvars
secondaryvars <- allvars[,c("cellnumbers","x","y","sand","clay")]

# Bring in secondary id variable from subsetcells
data(subsetcells)

# Remove duplicates (keeping only site-specific soils with site_ids ending
# in ".1").
subsetcells <- subsetcells[!duplicated(subsetcells$site_id),]

# Pull out matching variables only, with site_id that identifies unique climate
subsetcells <- subsetcells[,c("site_id","X_WGS84","Y_WGS84",
                              "sand","clay"),]

# Convert sand and clay to percentage from fraction
subsetcells$sand <- subsetcells$sand*100
subsetcells$clay <- subsetcells$clay*100

# Make sure subsetcell ids are unique
subsetcells$site_id <- paste0("00",subsetcells$site_id)

# Bring in "other" treatments
data(setsoiltypes)
other_treatments = setsoiltypes

# Calculate criteria
criteria = c((max(secondaryvars$sand,na.rm = T)-
                 min(secondaryvars$sand,na.rm = T))/10,
             (max(secondaryvars$clay,na.rm = T)-
                 min(secondaryvars$clay,na.rm = T))/10)

# Run secondary matching on soils data
quals2 <- secondaryMatching(secondaryvars = secondaryvars, matches = quals,
                            subsetcells=subsetcells,subsetcells_id = "site_id",
                            subset_in_target = FALSE, criteria = criteria,
                            raster_template = targetcells[[1]],
                            reference_treatment = "1",
                            other_treatments = other_treatments)

# Interpolate simulation output to rasters
interpolatePoints(matches = quals2, output_results = output_results,
                  exclude_poor_matches = TRUE,
                  subset_cell_names = "subset_cell_secondary",
                  quality_name = "matching_quality_secondary",
                  matching_distance = 1.5, raster_template = targetcells[[1]],
                  plotraster = TRUE, filepath = getwd(),
                  overwrite = FALSE)


}
\author{
Rachel R. Renne
}
